---
title : 浅谈Java与C++中的内存管理
tags: [Java,C++,内存分配,创建对象]
---

# 浅谈Java与C++中的内存管理

> 摘要：本文从内存管理的角度探讨了Java和C++这两种最流行的面向对象语言的特点，针对对象的创建与释放操作分析比较这两种语言在内存管理上的异同。

>关键字：Java；C++；内存分配；创建对象

## 0.内存管理概述

内存管理一直是程序设计领域永恒的话题，它对于一个程序的性能来说至关重要。对于Java和C++这两种目前最流行的编程语言来说，二者在内存管理方面有着截然不同的思路。对于C++程序员来说，在内存的控制上他们有着相对而言更大的权力，他们掌控着每一个对象从创建到销毁的整个生命周期。然而这是一把双刃剑，对于C++高手而言，这样的方式可以最精确、更自由地利用内存，有利于提高程序运行的效率。而对于C++菜鸟而言，他们经常被可恶的内存泄漏所折磨，所以很多人转向了Java 。在Java程序员看来，由于Java虚拟机的自动内存管理机制，他们几乎不需要手动管理内存，也很少出现内存泄露的问题。因此，Java中的内存泄露往往更加隐蔽，只有了解虚拟机管理内存的方式，Java程序员才能更好地提高程序性能。

## 1.内存分配区域

C++程序在运行时会将程序划分成几个区域，每个区域都有各自的用途。下图是一个C++程序运行时典型的内存分配布局：

![Memory Layout of a Process](http://o8jylft4f.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160610190335.png)

代码区主要用于存放程序的二进制代码；常量区主要用于存放常量值，不允许修改；全局数据区用于存放全局变量和静态变量；栈主要由编译器控制，用于处理函数调用时的参数传递及函数内的局部变量。这几个区域会在程序运行结束后由系统自动收回。堆用于应对由new与delete产生的动态内存需求。如果用new申请了内存但没有用delete释放，程序运行结束后它将仍然占据该内存。如果这一现象是由程序员的疏忽所致，就会造成内存泄漏。

根据《Java虚拟机规范（第二版）》的规定，Java虚拟机所管理的内存将会包括如下几个运行时数据区域：

![Java内存布局](http://o8jylft4f.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160610190407.png)

方法区主要用存放已被虚拟机加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据；虚拟机栈用于存储局部变量表、操作栈、动态链接、方法出口信息等；本地方法栈的作用与虚拟机栈非常类似，主要的区别在于虚拟机栈执行Java方法，本地方法栈执行本地方法；堆用来存放对象实例；程序计数器是一块较小的内存空间，是当前线程所执行的字节码行号指示器。所有区域均在虚拟机的管理、监控之下。

## 2.对象的创建
不论是Java还是C++，都采用同一种形式定义一个类，比如，下面的代码在两种语言中都适用：
```cpp
class Person
{
    int age;
    string name;
}
```

### 2.1 在C++中创建对象
对于上面定义的这个Person类，C++有两种创建对象的方式，比如在某函数中有如下代码：
```cpp
Person pa;
Person* pb = new Person();
```
对于前一行代码，因为代码是写在函数内部，因此pa是在该函数内有效的局部对象，在栈中安排相应的内存。后面一行代码的功能包括：在栈中安排一个指针变量pb，用new在堆中申请创建一个Person对象，假设申请是成功的，再将这个对象在堆中的首地址存入pb中。很明显，栈中安排的是对象pa和指针变量pb，而堆中安排的是用new申请到的对象。当然，前面一行代码也可以在Person前面加上static使其成为局部静态对象；或者写在函数之外，从而使其成为全局对象。这两种情况都将使得pa在全局数据区中安排内存。

### 2.2 在Java中创建对象
在Java语言中，创建对象的命令写作：
```Java
Person pc = new Person();
```
当然，这里包括着两项操作：创建对象，建立pc与该对象的关联关系。这两项操作也可以分开写在两行：
```Java
Person pc;
pc = new Person();
```

通常，以上代码出现在某一个方法体内，那么“Person pc”这一部分的语义将会反映到Java栈的本地变量表中，作为一个引用数据类型（reference）出现。而“new Person()”这部分的语义将会反映到Java堆中，形成一块存储了一个Person实例的各项数据的结构化内存。而代码当中的“=”就是建立本地变量pc对Java堆中那个实例的关联关系，在此之后，pc是该实例的引用。

### 2.3 对比
不难看出，在C++中，对象有可能在全局区、栈区和堆区分配内存，当然这
与创建对象的写法及代码写在什么位置有关。全局区对应着全局对象或者局部静态对象，栈区对应着局部对象，堆区对应用new申请的对象。在Java中，类的实例(即对象)必须在Java堆中安排内存，方法体内的变量只是相应实例的引用。可见，对创建及管理对象的环节，Java比C++简单很多。

## 3.对象的释放
为了充分利用内存，所有无用的对象都应该被释放，空出的内存可以供新的对象使用。C++和Java基于不同的出发点对回收内存采用了完全不同的方式。

### 3.1 释放C++中的对象
在C++中，根据对象创建的方式不同，采取相应的方式在销毁对象时收回内存。对于全局区中的对象，包括全局对象和静态局部对象，在程序运行结束后由系统进行处理；对于栈中的局部对象，在其相应的代码执行完毕时由系统处理；对于堆中的对象，在程序运行过程中执行delete语句时进行销毁。由于释放对象之前总是会调用析构函数，因此可以通过在析构函数中输出若干信息来查看对象何时被销毁。为此，可以为前述Person类编写如下的析构函数：
```cpp
~Person(){cout<<name<<" is deleted.\n";};
```
从以下代码的运行结果可以分析各个对象在何时销毁：
```cpp
Person a(20,"Tom");				//全局对象，在全局区安排
void main()
{
	Person b(21,"Jerry");		//局部对象，在栈中安排
	Person *q;
	q=new Person(22,"Peter");	//在堆中申请
	cout<<"==========\n";
	delete q;
}
```

上述代码的运行结果为：
```
Peter is deleted.
Jerry is deleted.
```
这里并没有看到全局的Tom被销毁，原因是销毁Tom的操作在整个程序运行结束的时候，而这时候显示结果的窗口也关闭了。如果在代码中去掉“delete q”这一行，则运行结果中就没有“Peter is deleted.”，说明Peter没有被销毁，这将造成内存泄漏。很遗憾，这个例子并不能说明在程序运行结束后Tom、Peter是否被销毁，如果想看到运行结束后Tom被销毁的痕迹则需要更高级的手段。

### 3.2	释放Java中的对象
Java虚拟机中存在一个叫做垃圾回收器（Garbage Collector）的系统级线程，它主要负责完成三件事情：分配内存、确保被引用的对象的内存不被错误的回收以及回收不再被引用的对象的内存空间。一般来说，为了保证程序性能，垃圾回收器仅仅在需要回收内存时才会启动，启动之前会调用finalize()方法来进行最后的清理。我们也可以调用System.gc()来手动启动垃圾回收器，为了观察垃圾收集行为，可以在Person类中重写finalize()方法：
```java
protected void finalize(){
	System.out.println("Person finalize is called.");
}
```
为了查看效果，编写下面的main：
```java
public static void main(String[] args) {
	Person p = new Person();
	p = null;
	System.gc();
}
```
实际上，垃圾回收器何时启动，以及如何回收无用对象取决于各个具体的Java环境采用的垃圾回收算法。以Sun的HotSpot VM为例，通过下面的代码可以窥探一下其垃圾回收的过程。为此，创建10000个Person对象然后调用finalize解除引用，为每个Person对象标上id，释放对象的id是1000的整数倍时打印输出：
``` java
	protected void finalize() throws Throwable{
		if (id % 1000 == 0) {
			System.out.println("Person finalize is called. id="+id);
		}
		super.finalize();
	}

	public static void main(String[] args) {
		Person[] pArr = new Person[10000];
		for (int i=0; i<pArr.length;i++ ) {
			pArr[i] = new Person();
		}
		pArr = null;
		System.gc();
	}
```
```
第一次运行：Person finalize is called. id=5000
			Person finalize is called. id=1000
第二次运行：Person finalize is called. id=2000
			Person finalize is called. id=3000
```
从中我们可以看出，垃圾回收器并不会回收所有无用对象，也不会按顺序回收，如果不调用GC，甚至在程序结束时垃圾回收器也不会启动。

### 3.3 对比
C++侧重于在对象的作用域终止时销毁对象并释放内存，同时又给程序员充分的自由，允许程序员创建出始终不销毁的对象。Java则选择减轻程序员的负担，让系统（即垃圾回收器）负责处理，因此Java语言没有销毁对象的delete，而把delete改作其它用途。

## 4.总结
本文简要介绍了Java与C++中内存管理方面的知识，包括程序运行时的内存管理、对象的创建与释放。两种语言在这一方面采用了不同的策略，各有各的特点。没有一种语言是完美的，语言只是一种工具，它们的特性决定了它们所应用的领域。比较好的策略是在性能要求特别高的系统采用C++进行研发，而界面复杂、内容繁多的应用软件则用Java编写。


参考文献：
* 1.Bruce Eckel. Thinking in Java 4th Edition[M]. 机械工业出版社 .2007
* 2.Stanley B. Lippman /Josée Lajoie /Barbara E. Moo C++ Primer[M], 4th Edition.
* 3.Kak Avinash C. Programming with Objects: A Comparative Presentation of Object-Oriented       Programming with C++ and Java[J]. Wiley-IEEE Press. 2003
* 4.周志明. 深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)[M]. 机械工业出版社 . 2011
